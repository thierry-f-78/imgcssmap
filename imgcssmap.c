#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

#include <png.h>
#include <jpeglib.h>

char color_mask[6] = {
	0xe0, /* 1 -> 3 bits */
	0xf0, /* 2 -> 4 bits */
	0xf8, /* 3 -> 5 bits */
	0xfc, /* 4 -> 6 bits */
	0xfe, /* 5 -> 7 bits */
	0xff, /* 6 -> 8 bits */
};

struct node {
	png_uint_32 width;
	png_uint_32 height;

	png_uint_32 surface;

	png_uint_32 dest_x;
	png_uint_32 dest_y;

	png_bytep *row_pointers;

	char *name;
	char *azname;
};

struct surface {
	unsigned char used;
	unsigned char r;
	unsigned char g;
	unsigned char b;
	unsigned char a;
};

enum template_elem_type {
	ELEM_STRING,

	ELEM_WIDTH,
	ELEM_HEIGHT,
	ELEM_OFFSETX,
	ELEM_OFFSETY,
	ELEM_NAME,
	ELEM_AZNAME,
	ELEM_ID,
};

struct template_elem {
	enum template_elem_type type;
	const char *string;
};

struct template {
	struct template *next;

	int nb;
	struct template_elem *elems;

	FILE *fh;
};

#define VAR_WIDTH   "$(width)"
#define VAR_HEIGHT  "$(height)"
#define VAR_OFFSETX "$(offsetx)"
#define VAR_OFFSETY "$(offsety)"
#define VAR_NAME    "$(name)"
#define VAR_AZNAME  "$(azname)"
#define VAR_ID      "$(id)"

void usage()
{
	fprintf(stderr, 
	"\n"
/*	 12345678901234567890123456789012345678901234567890123456789012345678901234567890 */
	"imgcssmap [-t in_file out_file [-t in out [...]]] [-q 1-6] [-i]\n"
	"          -o output_image input_file [...]\n"
	"\n"
	"   -t in_file out_file   in_file containing the template (typically CSS)\n"
	"                         out_file file generated by the template\n"
	"   -q 1-6                quality of colours. 6 is 8 bits per chanel quality\n"
	"                         5 is 7 bits, 4 is 6 bits, 3 is 5 bits, 2 is 4 bits\n"
	"                         and 1 is 3 bits\n"
	"   -i                    interlace png output image\n"
	"   -o output_image       image builded\n"
	"\n"
	"the template may contain this variables:\n"
	"   $(width)   the image width\n"
	"   $(height)  the image height\n"
	"   $(offsetx) the x offset of the image\n"
	"   $(offsety) the y offset of the image\n"
	"   $(name)    the image name without extension\n"
	"   $(azname)  the name only with this characters: 'a'-'z' '0'-'9' '_'\n"
	"   $(id)      the index after sorting. first image is 0.\n"
	"\n"
	);
}

static inline
void image_memory(struct node *n)
{
	int i;

	/* de la memoire pour charger l'image */
	n->row_pointers = calloc(sizeof(png_bytep), n->height);
	if (n->row_pointers == NULL) {
		fprintf(stderr, "out of memory\n");
		exit(1);
	}
	for (i=0; i<n->height; i++) {
		n->row_pointers[i] = calloc(n->width, 4);
		if (n->row_pointers[i] == NULL) {
			fprintf(stderr, "out of memory\n");
			exit(1);
		}
	}
}

struct node *openjpg(const char *filename)
{
	struct jpeg_decompress_struct cinfo;
	struct jpeg_error_mgr jerr;
	JSAMPROW row_pointer;
	FILE *infile;
	unsigned long location = 0;
	int i = 0;
	int x;
	struct node *n;

	infile = fopen(filename, "r");
	if (infile == NULL) {
		fprintf(stderr, "Error opening jpeg file %s\n!", filename);
		return NULL;
	}

	/* on fabrique le noeud qui va contenir l'image */
	n = malloc(sizeof(struct node));
	if (n == NULL) {
		fprintf(stderr, "out of memory\n");
		exit(1);
	}

	/* here we set up the standard libjpeg error handler */
	cinfo.err = jpeg_std_error(&jerr);

	/* setup decompression process and source, then read JPEG header */
	jpeg_create_decompress(&cinfo);

	/* this makes the library read from infile */
	jpeg_stdio_src(&cinfo, infile);

	/* reading the image header which contains image information */
	jpeg_read_header(&cinfo, TRUE);

#if 0
	printf( "Color components per pixel: %d.\n", cinfo.num_components );
	printf( "Color space: %d.\n", cinfo.jpeg_color_space );
#endif

	/* Uncomment the following to output image information, if needed. */
	n->width = cinfo.image_width;
	n->height = cinfo.image_height;
	n->surface = n->width * n->height;
 
	/* Start decompression jpeg here */
	jpeg_start_decompress(&cinfo);

	/* allocate memory to hold the uncompressed image */
	image_memory(n);

	/* now actually read the jpeg into the raw buffer */
	row_pointer = malloc(cinfo.output_width * cinfo.num_components);

	/* read one scan line at a time */
	location = 0;
	while (cinfo.output_scanline < cinfo.image_height) {

		/* read one line */
		jpeg_read_scanlines(&cinfo, &row_pointer, 1);

		/* copy RGB line */
		if (cinfo.jpeg_color_space == JCS_RGB || 
		    cinfo.jpeg_color_space == JCS_YCbCr) {
			x = 0;
			for (i=0; i<n->width*3; i+=3) {
				n->row_pointers[location][x+0] = row_pointer[i+0];
				n->row_pointers[location][x+1] = row_pointer[i+1];
				n->row_pointers[location][x+2] = row_pointer[i+2];
				n->row_pointers[location][x+3] = 0xff;
				x += 4;
			}
		}

		/* copy yuv line */
#if 0
		if (cinfo.jpeg_color_space == JCS_YCbCr) {
			double y;
			double u;
			double v;
			double r;
			double g;
			double b;
			x = 0;
			for (i=0; i<n->width*3; i+=3) {

				y = row_pointer[i+0];
				u = row_pointer[i+1];
				v = row_pointer[i+2];

				r = ( 1.164 * (y - 16) ) + ( 1.596 * (v - 128) );
				g = ( 1.164 * (y - 16) ) - ( 0.813 * (v - 128) ) - ( 0.391* (u - 128) );
				b = ( 1.164 * (y - 16) ) + ( 2.018 * (u - 128) );

				n->row_pointers[location][x+0] = r;
				n->row_pointers[location][x+1] = g;
				n->row_pointers[location][x+2] = b;
				n->row_pointers[location][x+3] = 0xff;

				x += 4;
			}
		}
#endif

		/* copy and convert grayscale line */
		if (cinfo.jpeg_color_space == JCS_GRAYSCALE) {	
			x = 0;
			for (i=0; i<n->width; i++) {
				n->row_pointers[location][x+0] = row_pointer[i+0];
				n->row_pointers[location][x+1] = row_pointer[i+0];
				n->row_pointers[location][x+2] = row_pointer[i+0];
				n->row_pointers[location][x+3] = 0xff;
				x += 4;
			}
		}

		/* next line */
		location++;
	}

	/* wrap up decompression, destroy objects, free pointers and close open files */
	jpeg_finish_decompress(&cinfo);
	jpeg_destroy_decompress(&cinfo);
	free(row_pointer);
	fclose(infile);

	/* yup, we succeeded! */
	return n;
}

struct node *openpng(const char *name)
{
	unsigned char sig[8];
	struct node *n;
	FILE *fh;
	png_structp png_ptr;
	png_infop info_ptr;
	int bit_depth;
	int color_type;

	/* ouverture du fichier */
	fh = fopen(name, "r");
	if (fh == NULL) {
		fprintf(stderr, "cannot open file \"%s\": %s\n",
		        name, strerror(errno));
		exit(1);
	}

	/* on verifie la signature */
	fread(sig, 1, 8, fh);
	if (!png_check_sig(sig, 8)) {
		fprintf(stderr, "bad png signature \"%s\"\n", name);
		exit(1);
	}

	/* on fabrique le noeud qui va contenir l'image */
	n = malloc(sizeof(struct node));
	if (n == NULL) {
		fprintf(stderr, "out of memory\n");
		exit(1);
	}

	/* on fabrique la structure qui va recevoir l'image */
	png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
	if (!png_ptr) {
		fprintf(stderr, "out of memory\n");
		exit(1);
	}

	/* on fabrique la structure qui contient les infos sur l'image */
	info_ptr = png_create_info_struct(png_ptr);
	if (!info_ptr) {
		fprintf(stderr, "out of memory\n");
		exit(1);
	}

	/* traitement des erreurs */
	if (setjmp(png_ptr->jmpbuf)) {
		fprintf(stderr, "png read \"%s\" error\n", name);
		exit(1);
	}

	/* positionne le handler du fichier qui sera utilisé pour la lecture */
	png_init_io(png_ptr, fh);

	/* do not check the signature */
	png_set_sig_bytes(png_ptr, 8);

	/* read the png file info */
	png_read_info(png_ptr, info_ptr);

	/* recupere les infos concernant l'image */
	png_get_IHDR(png_ptr, info_ptr,
	             &n->width, &n->height, &bit_depth, &color_type,
	             NULL, NULL, NULL);
	
	/* on convertit le "gray" en RGB */
	if ((color_type & PNG_COLOR_MASK_COLOR) == 0) {

		/* transform grayscale of less than 8 to 8 bits */
		if (bit_depth < 8)
			png_set_gray_1_2_4_to_8(png_ptr);

		png_set_gray_to_rgb(png_ptr);
	}

	/* changes paletted images to RGB */
	if ((color_type & PNG_COLOR_MASK_PALETTE) != 0)
		png_set_palette_to_rgb(png_ptr);
	
	/* PNG can have files with 16 bits per channel. If you only can handle 8 bits
	 * per channel, this will strip the pixels down to 8 bit.
	 */
	if (bit_depth == 16)
		png_set_strip_16(png_ptr);
	
	/* add alpha channel */
	if ((color_type & PNG_COLOR_MASK_ALPHA) == 0) {
		png_set_add_alpha(png_ptr, 0xff, PNG_FILLER_AFTER);
	}

	/* adds a full alpha channel if there is transparency information in a tRNS chunk */
	if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
		png_set_tRNS_to_alpha(png_ptr);
	
	/* calcule la surface de l'image */
	n->surface = n->width * n->height;

	/* de la memoire pour charger l'image */
	image_memory(n);

	/* load image */
	png_read_image(png_ptr, n->row_pointers);

	fclose(fh);
	png_destroy_read_struct(&png_ptr, &info_ptr, NULL);

	return n;
}

struct node *openimage(const char *name)
{
	const char *ext;

	/* get extension */
	ext = strrchr(name, '.');
	if (ext == NULL)
		return NULL;
	
	ext++;

	/* jpeg file */
	/**/ if (strcasecmp(ext, "jpg") == 0 ||
	         strcasecmp(ext, "jpeg") == 0)
		return openjpg(name);

	/* png file */
	else if (strcasecmp(ext, "png") == 0)
		return openpng(name);
	
	fprintf(stderr, "unmanaged file format \"%s\"\n", name);
	exit(1);
}

void drawpng(struct surface *buffer, int width, int height, int qual, int interlace, const char *name)
{
	FILE *fp;
	png_structp png_ptr;
	png_infop info_ptr;
	png_bytep row;
	int basex;
	int basey;
	int x;
	int y;
	int passes;
	int n;

	/* Open file for writing (binary mode) */
	fp = fopen(name, "wb");
	if (fp == NULL) {
		fprintf(stderr, "Could not open file %s for writing\n", name);
		exit(1);
	}

	/* Initialize write structure */
	png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
	if (png_ptr == NULL) {
		fprintf(stderr, "Could not allocate write struct\n");
		exit(1);
	}

	/* Initialize info structure */
	info_ptr = png_create_info_struct(png_ptr);
	if (info_ptr == NULL) {
		fprintf(stderr, "Could not allocate info struct\n");
		exit(1);
	}

	/* Setup Exception handling */
	if (setjmp(png_jmpbuf(png_ptr))) {
		fprintf(stderr, "Error during png creation\n");
		exit(1);
	}

	png_init_io(png_ptr, fp);

	/* Write header (8 bit colour depth + alpha) */
	png_set_IHDR(png_ptr, info_ptr, width, height,
	             8,
	             PNG_COLOR_TYPE_RGB_ALPHA,
	             interlace ?  PNG_INTERLACE_ADAM7 : PNG_INTERLACE_NONE, 
	             PNG_COMPRESSION_TYPE_BASE,
	             PNG_FILTER_TYPE_BASE);

	/* write png info into file */
	png_write_info(png_ptr, info_ptr);

	/* Allocate memory for one row (3 bytes per pixel - RGB) */
	row = (png_bytep) malloc(4 * width * sizeof(png_byte));

	/* number of passes */
	if (interlace)
		passes = png_set_interlace_handling(png_ptr);
	else
		passes = 1;

	/* Write image data */
	for(n=0; n<passes; n++) {
		for (y=0 ; y<height ; y++) {
			basey = y * width;
			for (x=0 ; x<width ; x++) {
				basex = x * 4;
				if (buffer[y*width + x].used != 0) {
					if (buffer[basey+x].a != 0x00) {
						row[basex+0] = buffer[basey+x].r & color_mask[qual];
						row[basex+1] = buffer[basey+x].g & color_mask[qual];
						row[basex+2] = buffer[basey+x].b & color_mask[qual];
						row[basex+3] = buffer[basey+x].a & color_mask[qual];
					} else {
						row[basex+0] = 0x00;
						row[basex+1] = 0x00;
						row[basex+2] = 0x00;
						row[basex+3] = 0x00;
					}
				} else {
					row[basex+0] = 0x00;
					row[basex+1] = 0x00;
					row[basex+2] = 0x00;
					row[basex+3] = 0x00;
				}
			}
			png_write_row(png_ptr, row);
		}
	}

	/* End write */
	png_write_end(png_ptr, NULL);
	fclose(fp);
	png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
	png_destroy_write_struct(&png_ptr, (png_infopp)NULL);
	free(row);
}

struct template *load_tpl(const char *in_file, const char *out_file)
{
	enum template_elem_type type;
	struct template *tpl;
	int fd;
	struct stat buf;
	char *bloc;
	char *var;
	char *nvar;
	char *p;
	char *cont;

	/* memory for the template */
	tpl = calloc(sizeof(struct template), 1);
	if (tpl == NULL) {
		fprintf(stderr, "out of memory\n");
		exit(1);
	}

	/* open output template file */
	tpl->fh = fopen(out_file, "w");
	if (tpl->fh == NULL) {
		fprintf(stderr, "cannot open file \"%s\": %s\n",
		        out_file, strerror(errno));
		exit(1);
	}

	/* get size */
	if (stat(in_file, &buf) < 0) {
		fprintf(stderr, "cannot open file \"%s\": %s\n",
		        in_file, strerror(errno));
		exit(1);
	}

	/* open input template file */
	fd = open(in_file, O_RDONLY);
	if (fd < 0) {
		fprintf(stderr, "cannot open file \"%s\": %s\n",
		        in_file, strerror(errno));
		exit(1);
	}

	/* memory for data */
	bloc = malloc(buf.st_size + 1);
	if (bloc == NULL) {
		fprintf(stderr, "out of memory\n");
		exit(1);
	}

	/* load data */
	if (read(fd, bloc, buf.st_size) != buf.st_size) {
		fprintf(stderr, "cannot read file \"%s\": %s\n",
		        in_file, strerror(errno));
		exit(1);
	}
	bloc[buf.st_size] = '\0';

	/* close inpout template file */
	close(fd);

	/* on decoupe tout ça */
	p = bloc;
	while (1) {

		/* on recherche la premiere occurrence de la premiere variable */
		var = strstr(p, VAR_WIDTH);
		if (var !=  NULL) {
			type = ELEM_WIDTH;
			cont = var + strlen(VAR_WIDTH);
		}
		nvar = strstr(p, VAR_HEIGHT);
		if (var == NULL || (nvar != NULL && nvar < var)) {
			var = nvar;
			type = ELEM_HEIGHT;
			cont = var + strlen(VAR_HEIGHT);
		}
		nvar = strstr(p, VAR_OFFSETX);
		if (var == NULL || (nvar != NULL && nvar < var)) {
			var = nvar;
			type = ELEM_OFFSETX;
			cont = var + strlen(VAR_OFFSETX);
		}
		nvar = strstr(p, VAR_OFFSETY);
		if (var == NULL || (nvar != NULL && nvar < var)) {
			var = nvar;
			type = ELEM_OFFSETY;
			cont = var + strlen(VAR_OFFSETY);
		}
		nvar = strstr(p, VAR_NAME);
		if (var == NULL || (nvar != NULL && nvar < var)) {
			var = nvar;
			type = ELEM_NAME;
			cont = var + strlen(VAR_NAME);
		}
		nvar = strstr(p, VAR_AZNAME);
		if (var == NULL || (nvar != NULL && nvar < var)) {
			var = nvar;
			type = ELEM_AZNAME;
			cont = var + strlen(VAR_AZNAME);
		}
		nvar = strstr(p, VAR_ID);
		if (var == NULL || (nvar != NULL && nvar < var)) {
			var = nvar;
			type = ELEM_ID;
			cont = var + strlen(VAR_ID);
		}

		/* copy string if is not empty */
		if (p != var) {
			tpl->nb++;
			tpl->elems = realloc(tpl->elems, sizeof(struct template_elem) * tpl->nb);
			if (tpl->elems == NULL) {
				fprintf(stderr, "out of memory\n");
				exit(1);
			}
			tpl->elems[tpl->nb-1].string = p;
			tpl->elems[tpl->nb-1].type = ELEM_STRING;
		}

		/* copy variable element */
		if (var != NULL) {
			*var = '\0'; /* end of previous string */
			tpl->nb++;
			tpl->elems = realloc(tpl->elems, sizeof(struct template_elem) * tpl->nb);
			if (tpl->elems == NULL) {
				fprintf(stderr, "out of memory\n");
				exit(1);
			}
			tpl->elems[tpl->nb-1].string = NULL;
			tpl->elems[tpl->nb-1].type = type;
		}

		/* is the end of parsing */
		else
			break;
		
		/* continue parsing */
		p = cont;
	}

	return tpl;
}

void exec_tpl(struct template *tpl, struct node *node, int id)
{
	int i;

	for (i=0; i<tpl->nb; i++) {
		switch(tpl->elems[i].type) {
		case ELEM_STRING:
			fprintf(tpl->fh, "%s", tpl->elems[i].string);
			break;
		case ELEM_WIDTH:
			fprintf(tpl->fh, "%lu", node->width);
			break;
		case ELEM_HEIGHT:
			fprintf(tpl->fh, "%lu", node->height);
			break;
		case ELEM_OFFSETX:
			fprintf(tpl->fh, "%lu", node->dest_x);
			break;
		case ELEM_OFFSETY:
			fprintf(tpl->fh, "%lu", node->dest_y);
			break;
		case ELEM_NAME:
			fprintf(tpl->fh, "%s", node->name);
			break;
		case ELEM_AZNAME:
			fprintf(tpl->fh, "%s", node->azname);
			break;
		case ELEM_ID:
			fprintf(tpl->fh, "%d", id);
			break;
		}
	}
}

void close_tpl(struct template *tpl)
{
	fclose(tpl->fh);
}

static inline
int check_size(struct surface *surf, int larg, int sx, int sy, int width, int height)
{
	int x;
	int y;
	int base;

	for (y=sy; y<sy+height; y++) {
		base = y * larg;
		for (x=sx; x<sx+width; x++)
			if (surf[base + x].used != 0)
				return 0;
	}
	return 1;
}

static inline
void fill(struct surface *surf, int larg, int sx, int sy, struct node *n)
{
	int x;
	int y;
	int base;
	int py;
	int px;

	py = 0;
	for (y=sy; y<sy+n->height; y++) {
		base = y * larg;
		px = 0;
		for (x=sx; x<sx+n->width; x++) {
			surf[base + x].used = 1;
			surf[base + x].r = n->row_pointers[py][px+0];
			surf[base + x].g = n->row_pointers[py][px+1];
			surf[base + x].b = n->row_pointers[py][px+2];
			surf[base + x].a = n->row_pointers[py][px+3];
			px += 4;
		}
		py++;
	}
}

int compar(const void *ia, const void *ib)
{
	const struct node * const *ia1 = ia;
	const struct node * const *ib1 = ib;
	const struct node *a = *ia1;
	const struct node *b = *ib1;

	return a->surface < b->surface;
}

char *do_azname(const char *name)
{
	char *p;
	char *n;

	/* search path component */
	p = strchr(name, '/');
	if (p == NULL)
		p = (char *)name;
	else
		p++;

	/* copy name without path component */
	n = strdup(p);
	if (n == NULL) {
		fprintf(stderr, "out of memory\n");
		exit(1);
	}

	/* remove extension */
	p = strrchr(n, '.');
	if (p != NULL)
		*p = '\0';

	/* check each char */
	for (p = n;
	     *p != '\0';
	     p++) {

		/* lower case */
		if (*p >= 'A' && *p <= 'Z')
			*p = tolower(*p);

		/* replace bad char */
		if ( (*p < 'a' || *p > 'z') &&
		     (*p < '0' || *p > '9') &&
		     *p != '_')
			*p = '_';
	}

	return n;
}

int main(int argc, char *argv[])
{
	int smin = 0;
	int ymax = 0;
	int xmin = 0;
	int larg;
	int i;
	struct surface *surf;
	struct node **pool;
	struct node *node;
	int x;
	int y;
	int top = 0;
	int nb_img;
	int idx = 0;
	int do_break;
	const char *output_image = NULL;
	const char *in;
	const char *out;
	struct template *templates = NULL;
	struct template *tpl;
	char *error;
	int qual = 5;
	int interlace = 0;

	/* memoire pour le tri */
	pool = calloc(sizeof(struct node *), argc - 1);

	/* load options */
	for (i=1; i<argc; i++) {

		/*
		 *
		 * output image file
		 *
		 */
		/**/ if (strcmp(argv[i], "-o") == 0) {
			i++;
			if (i >= argc) {
				fprintf(stderr, "option -i expect file\n");
				usage();
				exit(1);
			}
			output_image = argv[i];
		}

		/*
		 *
		 * load template
		 *
		 */
		else if (strcmp(argv[i], "-t") == 0) {

			i++;
			if (i >= argc) {
				fprintf(stderr, "option -t expect input file\n");
				usage();
				exit(1);
			}
			in = argv[i];

			i++;
			if (i >= argc) {
				fprintf(stderr, "option -t expect output file\n");
				usage();
				exit(1);
			}
			out = argv[i];

			tpl = load_tpl(in, out);
			tpl->next = templates;
			templates = tpl;
		}

		/*
		 *
		 * image quality
		 *
		 */
		else if (strcmp(argv[i], "-q") == 0) {
			i++;
			if (i >= argc) {
				fprintf(stderr, "option -q expect a value from 1 to 6\n");
				usage();
				exit(1);
			}
			qual = strtol(argv[i], &error, 10);
			if (*error != '\0' || qual < 1 || qual > 6) {
				fprintf(stderr, "option -q expect a value from 1 to 6\n");
				usage();
				exit(1);
			}
			qual--;
		}

		/*
		 *
		 * interlace
		 *
		 */
		else if (strcmp(argv[i], "-i") == 0) {
			interlace = 1;
		}

		/*
		 * 
		 * end of option, now load images
		 *
		 */
		else
			break;
	}

	/* no input files */
	if (i >= argc) {
		fprintf(stderr, "no input files\n");
		usage();
		exit(1);
	}

	/* check configuration */
	if (output_image == NULL) {
		fprintf(stderr, "no outimage\n");
		usage();
		exit(1);
	}

	/* number of images */
	nb_img = argc - i;

	/* charge les images */
	for (; i<argc; i++) {

		/* open png image */
		node = openimage(argv[i]);
		if (node == NULL) {
			nb_img --;
			continue;
		}

		/* copy name */
		node->name = argv[i];
		node->azname = do_azname(argv[i]);

		/* index png image */
		pool[idx] = node;
		idx++;

		/* calcul de la surface minimale */
		smin += node->surface;

		/* calcul de la largeur minimale */
		if (node->width > xmin)
			xmin = node->width;

		/* hauteur maximale */
		ymax += node->height;
	}

	/* nothing to do */
	if (nb_img == 0)
		exit(0);

	/* Calcule la largeur */
	larg = sqrt(smin) + 1;
	if (larg < xmin)
		larg = xmin;

	/* memoire pour la surface de placement */
	surf = calloc(sizeof(struct surface), larg * ymax);

	/* on ordone les images */
	qsort(pool, nb_img, sizeof(struct node *), compar);

	/* on va placer les locs par ordre de taille */
	for (i=0; i<nb_img; i++) {

		/* get node */
		node = pool[i];

		/* on place le noeud
		 * on scanne l'espace libre de gaucha a droite puis de haut en bas
		 */
		do_break = 0;
		for (y=0; y<ymax-node->height+1; y++) {
			for (x=0; x<larg-node->width+1; x++) {

				/* on verifie l'espace libre 
				 * on scanne uniquement la zone dans laquelle l'image
				 * peut potentiellement contenir
				 */
				if (check_size(surf, larg, x, y, node->width, node->height)) {
					fill(surf, larg, x, y, node);

					/* on met à jour la hauteur de l'image */
					if (top < y + node->height)
						top = y + node->height;

					/* on note les coordonnées de destination */
					node->dest_x = x;
					node->dest_y = y;

					/* fin du scan pour cette image */
					do_break = 1;
					break;
				}
			}
			if (do_break)
				break;
		}

		/* execute template */
		for (tpl = templates;
		     tpl != NULL; 
		     tpl = tpl->next)
			exec_tpl(tpl, node, i);
	}

	/* draw png outpout image */
	drawpng(surf, larg, top, qual, interlace, output_image);

	/* close templates */
	for (tpl = templates;
	     tpl != NULL; 
	     tpl = tpl->next)
		close_tpl(tpl);

	return 0;
}
